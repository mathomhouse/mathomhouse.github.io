<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Map Editor</title>
  <style>
    :root{
      --cell: 18px; /* change for bigger/smaller cells */
      --gap: 1px;
      --bg: #0b0b0c;
      --panel: #121218;
      --panel-2: #1a1a22;
      --text: #e9e9ef;
      --muted: #9aa0a6;
      --accent: #6ea8ff;
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background: linear-gradient(180deg, #0b0b0c, #0f1016);
      color: var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-columns: 380px 1fr; /* wider for manager */
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header"
        "sidebar main";
    }

    header{
      grid-area: header;
      padding: 12px 16px;
      background: #0e0f14;
      border-bottom: 1px solid #23232b;
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    header h1{ font-size: 16px; margin: 0; letter-spacing: .3px; }
    header .spacer{ flex: 1; }
    header .btn{
      background: var(--panel-2);
      border: 1px solid #2a2a34;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
    }
    header .btn:hover{ filter: brightness(1.1); }

    /* Sidebar */
    aside{
      grid-area: sidebar;
      background: var(--panel);
      border-right: 1px solid #23232b;
      padding: 14px;
      overflow: auto;
    }
    aside h2{ font-size: 13px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); margin: 8px 0 10px; }

    .palette{ display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }
    .swatch-btn{
      display:flex; align-items:center; gap:8px; width:100%;
      padding:8px; background: var(--panel-2); border:1px solid #2a2a34; border-radius: 10px; color:var(--text); cursor:pointer;
    }
    .swatch-btn[aria-pressed="true"]{ outline: 2px solid var(--accent); }
    .swatch{ width:20px; height:20px; border-radius:4px; border:1px solid #0008; box-shadow: inset 0 0 0 1px #ffffff22; }

    label.inline{ display:flex; align-items:center; gap:8px; margin: 8px 0; }
    input[type="number"], input[type="text"], input[type="color"], select{ background:#0e0f14; color:var(--text); border:1px solid #2a2a34; border-radius:8px; padding:6px 8px; }
    input[type="number"], select{ width:100%; }

    .toolbar{ display:grid; grid-template-columns: repeat(3,1fr); gap:8px; }
    .btn{ background: var(--panel-2); border: 1px solid #2a2a34; color: var(--text); padding: 8px 10px; border-radius: 10px; cursor: pointer; }
    .btn-xs{ padding:4px 6px; border-radius:8px; font-size:12px; }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }
    .btn[aria-pressed="true"]{ outline:2px solid var(--accent); }

    .note{ color: var(--muted); font-size: 12px; }

    /* Label Manager */
    .list{ display:grid; gap:8px; }
    .item{ display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:8px; background:var(--panel-2); border:1px solid #2a2a34; border-radius:12px; padding:8px; }
    .item .tag{ font-weight:700; padding:2px 8px; border-radius:6px; background:#2a2a34; }
    .item .meta{ color:var(--muted); font-size:12px; }
    .item .btns{ display:flex; gap:6px; }

    /* Palette Manager */
    .pm-list{ display:grid; gap:8px; }
    .pm-row{ display:grid; grid-template-columns: auto 1fr auto auto; align-items:center; gap:8px; background:var(--panel-2); border:1px solid #2a2a34; border-radius:12px; padding:8px; }
    .pm-row .key{ color:var(--muted); font-size:12px; }

    /* Main canvas */
    main{ grid-area: main; display:grid; place-items:center; overflow:auto; }

    .grid-wrap{ position: relative; padding: 18px; }
    .grid{
      --cols: 50;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--cell));
      grid-auto-rows: var(--cell);
      gap: var(--gap);
      background: #1c1c24;
      border: 1px solid #2a2a34;
      padding: var(--gap);
      border-radius: 14px;
      box-shadow: 0 10px 30px #0006, inset 0 0 0 1px #ffffff10;
      image-rendering: pixelated;
      user-select: none;
      touch-action: none; /* smoother touch drag */
    }
    .cell{
      position: relative;
      width: var(--cell);
      height: var(--cell);
      background: #f2f4f7; /* Remaining Area */
      border-radius: 3px;
      box-shadow: inset 0 0 0 1px #00000011;
    }

    /* cell-centered label */
    .cell .lbl{
      pointer-events: none;
      position: absolute; inset: 0; display:flex; align-items:center; justify-content:center;
      font-weight: 700; line-height: 1; letter-spacing: .02em;
      font-size: 11px; /* auto-scaled on export */
      color: #ffffff; /* white text */
      text-shadow:
        -1px 0 #000, 1px 0 #000, 0 -1px #000, 0 1px #000,
        -1px -1px #000, 1px 1px #000, -1px 1px #000, 1px -1px #000; /* outline for contrast */
    }

    /* Flash highlight for jump */
    @keyframes flashRing{ 0%{outline-color:transparent;} 30%{outline-color:var(--accent);} 100%{outline-color:transparent;} }
    .cell.flash{ outline: 2px solid var(--accent); outline-offset: -2px; animation: flashRing .9s ease; }

  </style>
  <script src="header.js" defer></script>
</head>
<body>
  <header id="header-placeholder"></header>
  <header>
    <h1>Map Editor</h1>
    <div class="spacer"></div>
    <button id="btnExportPNG" class="btn" title="Download a PNG of the current map">Export PNG</button>
    <button id="btnSaveJSON" class="btn" title="Download a JSON file you can load later">Save JSON</button>
    <button id="btnLoadJSON" class="btn" title="Load a previously saved JSON file">Load JSON</button>
    <input id="fileInput" type="file" accept="application/json" hidden />
  </header>

  <aside>
    <h2>Palette</h2>
    <div id="palette" class="palette"></div>

    <h2>Tools & Grid</h2>
    <div class="toolbar" style="margin-bottom:10px;">
      <button id="toolBrush" class="btn" aria-pressed="true">Brush</button>
      <button id="toolEraser" class="btn">Eraser</button>
      <button id="toolLabel" class="btn">Label</button>
    </div>

    <label class="inline">Brush size
      <input id="brushSize" type="number" min="1" max="5" value="1"/>
    </label>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
      <label class="inline">Cols
        <input id="cols" type="number" min="8" max="120" value="50" />
      </label>
      <label class="inline">Rows
        <input id="rows" type="number" min="8" max="120" value="50" />
      </label>
    </div>
    <div class="toolbar" style="margin-top:8px; grid-template-columns: repeat(2,1fr);">
      <button id="btnResize" class="btn">Resize / Clear</button>
      <button id="btnSeed" class="btn" title="Draw a small core with gates in the center">Seed Template</button>
    </div>

    <h2>POIs & Labels</h2>
    <div class="list" id="labelList"></div>
    <div style="display:flex; gap:8px; margin:8px 0 16px;">
      <button id="btnExportLabels" class="btn" title="Export labels as CSV">Export Labels CSV</button>
      <button id="btnClearLabels" class="btn" title="Remove all labels">Clear</button>
    </div>

    <h2>Palette Manager</h2>
    <div id="pmList" class="pm-list"></div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <input id="pmNewName" type="text" placeholder="New type name" />
      <input id="pmNewColor" type="color" value="#888888" />
      <button id="pmAdd" class="btn">Add Type</button>
    </div>

    <p class="note" style="margin-top:12px;">Tips: Paint = drag • Erase = right‑click • Line = hold <kbd>Shift</kbd> • <strong>Labels:</strong> choose <em>Label</em>, click a cell to enter text (blank to remove). Right‑click while on Label tool removes a label.</p>
  </aside>

  <main>
    <div class="grid-wrap">
      <div id="grid" class="grid" role="grid" aria-label="Editable map grid"></div>
    </div>
  </main>

  <script>
    // ---- Configuration ----
    let PALETTE = [
      { key: 'entrance', name: 'Entrances',  color: '#0066cc' }, // blue
      { key: 'walls',    name: 'Walls',            color: '#ffd400' }, // yellow
      { key: 'forts',    name: 'Fortresses', color: '#db0b19' }, // red
      { key: 'deploy',   name: 'Deployment Area',  color: '#ff59cf' }, // magenta
      { key: 'gates',    name: 'Gates',      color: '#2f3132' }, // dark gray
      { key: 'core',     name: 'Core',             color: '#03a34a' }, // green
      { key: 'empty',    name: 'Remaining Area',   color: '#f2f4f7' }, // white (non-deletable)
    ];

    // ---- State ----
    let rows = 50, cols = 50;
    let brush = 'core';
    let tool = 'brush'; // 'brush' | 'eraser' | 'label'
    let brushSize = 1;
    let isMouseDown = false;
    let lastCell = null; // for shift-line drawing

    const gridEl   = document.getElementById('grid');
    const paletteEl= document.getElementById('palette');
    const labelListEl = document.getElementById('labelList');
    const pmListEl = document.getElementById('pmList');

    // Label storage (cell -> text)
    const labelMap = new Map(); // key: "r,c" -> text
    const keyFor = (r,c) => `${r},${c}`;
    function setLabel(r,c,text){ labelMap.set(keyFor(r,c), text); updateCellLabelDOM(r,c); renderLabelList(); }
    function removeLabel(r,c){ labelMap.delete(keyFor(r,c)); updateCellLabelDOM(r,c); renderLabelList(); }
    function getLabel(r,c){ return labelMap.get(keyFor(r,c)); }

    function updateCellLabelDOM(r,c){
      const idx = r*cols + c; const cell = gridEl.children[idx]; if(!cell) return;
      let span = cell.querySelector('.lbl');
      const text = getLabel(r,c);
      if(text && text.trim()){
        if(!span){ span = document.createElement('span'); span.className = 'lbl'; cell.appendChild(span); }
        span.textContent = text;
      } else if(span) { span.remove(); }
    }
    function paintAllLabels(){
      for(const cell of gridEl.children){ const s = cell.querySelector('.lbl'); if(s) s.remove(); }
      for(const [k, text] of labelMap){ const [r,c] = k.split(',').map(Number); updateCellLabelDOM(r,c); }
      renderLabelList();
    }

    // ---- Palette helpers ----
    function keyToColor(key){ const p = PALETTE.find(p=>p.key===key); return (p?p.color:'#f2f4f7'); }
    function keyExists(key){ return PALETTE.some(p=>p.key===key); }
    function refreshCellsForKey(key){
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(matrix[r][c]===key){
        gridEl.children[r*cols+c].style.background = keyToColor(key);
      }
    }

    // Build quick-select palette
    function buildPalette(){
      paletteEl.innerHTML = '';
      PALETTE.forEach((p) => {
        const btn = document.createElement('button');
        btn.className = 'swatch-btn';
        btn.setAttribute('type','button');
        btn.setAttribute('aria-pressed', p.key === brush);
        btn.dataset.key = p.key;
        btn.innerHTML = `<span class="swatch" style="background:${p.color}"></span><span>${p.name}</span>`;
        btn.addEventListener('click', () => {
          brush = p.key;
          document.querySelectorAll('.swatch-btn').forEach(b=>b.setAttribute('aria-pressed','false'));
          btn.setAttribute('aria-pressed','true');
        });
        paletteEl.appendChild(btn);
      });
      buildPaletteManager();
    }

    // ---- Palette Manager ----
    function uniqueKey(base){
      let k = base.replace(/[^a-z0-9]+/gi,'').toLowerCase() || 'type';
      if(!isNaN(k[0])) k = 't' + k;
      let i = 1; let want = k;
      while(PALETTE.some(p=>p.key===want)) want = k + i++;
      return want;
    }

    function buildPaletteManager(){
      pmListEl.innerHTML = '';
      for(const p of PALETTE){
        const row = document.createElement('div'); row.className = 'pm-row';
        const color = document.createElement('input'); color.type='color'; color.value = p.color; color.title = 'Color';
        color.addEventListener('input', ()=>{ p.color = color.value; refreshCellsForKey(p.key); buildPalette(); });
        const name = document.createElement('input'); name.type='text'; name.value = p.name; name.placeholder = 'Name';
        name.addEventListener('change', ()=>{ p.name = name.value || p.name; buildPalette(); });
        const keySpan = document.createElement('span'); keySpan.className='key'; keySpan.textContent = p.key;
        const del = document.createElement('button'); del.className='btn btn-xs'; del.textContent = 'Delete';
        del.disabled = (p.key === 'empty');
        del.addEventListener('click', ()=>{
          if(!confirm(`Delete type "${p.name}" and convert its cells to Remaining Area?`)) return;
          // Replace its cells with 'empty'
          for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(matrix[r][c]===p.key) matrix[r][c]='empty';
          // Remove from palette
          PALETTE = PALETTE.filter(x=>x.key!==p.key);
          paintAllFromMatrix(); buildPalette();
        });
        const use = document.createElement('button'); use.className='btn btn-xs'; use.textContent='Use';
        use.addEventListener('click', ()=>{ brush = p.key; document.querySelectorAll('.swatch-btn').forEach(b=>b.setAttribute('aria-pressed','false')); const sw = [...document.querySelectorAll('.swatch-btn')].find(b=>b.dataset.key===p.key); if(sw) sw.setAttribute('aria-pressed','true'); });

        row.appendChild(color); row.appendChild(name); row.appendChild(keySpan); row.appendChild(use); row.appendChild(del);
        pmListEl.appendChild(row);
      }
    }

    document.getElementById('pmAdd').addEventListener('click', ()=>{
      const name = (document.getElementById('pmNewName').value || 'Type').trim();
      const color = document.getElementById('pmNewColor').value || '#888888';
      const key = uniqueKey(name);
      PALETTE.splice(PALETTE.length-1, 0, { key, name, color }); // insert before 'empty'
      document.getElementById('pmNewName').value = '';
      buildPalette();
    });

    // ---- Grid/matrix ----
    let matrix = [];
    function makeMatrix(r, c, fill='empty'){
      return Array.from({length:r}, () => Array.from({length:c}, () => fill));
    }

    function rebuildGrid(){
      gridEl.style.setProperty('--cols', cols);
      gridEl.innerHTML = '';
      matrix = makeMatrix(rows, cols, 'empty');
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.tabIndex = 0;
          cell.dataset.r = r;
          cell.dataset.c = c;
          gridEl.appendChild(cell);
        }
      }
      paintAllFromMatrix();
      paintAllLabels();
    }

    function setCell(r,c,key){
      if(r<0||c<0||r>=rows||c>=cols) return;
      if(!keyExists(key)) key='empty';
      matrix[r][c] = key;
      const idx = r*cols + c; const cell = gridEl.children[idx]; if(cell) cell.style.background = keyToColor(key);
    }
    function getCellKey(r,c){ return (matrix[r] && matrix[r][c]) || 'empty'; }

    function paintAllFromMatrix(){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const idx = r*cols + c;
          gridEl.children[idx].style.background = keyToColor(matrix[r][c]);
        }
      }
    }

    // Painting logic
    function paintAt(r,c){
      const radius = Math.max(1, Math.floor(brushSize));
      const half = Math.floor(radius/2);
      for(let dr=0; dr<radius; dr++){
        for(let dc=0; dc<radius; dc++){
          const rr = r + dr - half;
          const cc = c + dc - half;
          if(tool === 'eraser') setCell(rr,cc,'empty'); else setCell(rr,cc,brush);
        }
      }
    }

    function linePaint(r0,c0,r1,c1){
      let dx = Math.abs(c1 - c0), sx = c0 < c1 ? 1 : -1;
      let dy = -Math.abs(r1 - r0), sy = r0 < r1 ? 1 : -1; 
      let err = dx + dy, e2;
      while(true){
        paintAt(r0,c0);
        if (c0 === c1 && r0 === r1) break;
        e2 = 2*err;
        if (e2 >= dy) { err += dy; c0 += sx; }
        if (e2 <= dx) { err += dx; r0 += sy; }
      }
    }

    gridEl.addEventListener('contextmenu', e => e.preventDefault());

    gridEl.addEventListener('pointerdown', (e) => {
      const target = e.target; if(!target.classList.contains('cell')) return; e.preventDefault(); isMouseDown = true;
      const r = +target.dataset.r; const c = +target.dataset.c;

      if(tool === 'label'){
        if(e.button === 2){ removeLabel(r,c); }
        else {
          const existing = getLabel(r,c) || '';
          const text = prompt('Label for this cell (blank to remove):', existing);
          if(text === null) { /* cancel */ }
          else if(!text.trim()) removeLabel(r,c);
          else setLabel(r,c, text.trim());
        }
        lastCell = target; return;
      }

      const useEraser = (e.button === 2 || e.ctrlKey);
      const prevTool = tool; if(useEraser) tool = 'eraser';
      if(e.shiftKey && lastCell){ linePaint(+lastCell.dataset.r, +lastCell.dataset.c, r, c); } else { paintAt(r,c); }
      if(useEraser) tool = prevTool;
      lastCell = target;
    });

    gridEl.addEventListener('pointermove', (e) => {
      if(!isMouseDown) return;
      const target = e.target; if(!target.classList.contains('cell')) return;
      const r = +target.dataset.r; const c = +target.dataset.c;
      if(tool === 'label') return; // no drag labels
      paintAt(r,c); lastCell = target;
    });
    window.addEventListener('pointerup', () => { isMouseDown = false; });

    // Controls
    function setTool(name){
      tool = name;
      document.getElementById('toolBrush').setAttribute('aria-pressed', String(name==='brush'));
      document.getElementById('toolEraser').setAttribute('aria-pressed', String(name==='eraser'));
      document.getElementById('toolLabel').setAttribute('aria-pressed', String(name==='label'));
    }
    document.getElementById('toolBrush').addEventListener('click', () => setTool('brush'));
    document.getElementById('toolEraser').addEventListener('click', () => setTool('eraser'));
    document.getElementById('toolLabel').addEventListener('click', () => setTool('label'));

    document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value || 1);

    document.getElementById('btnResize').addEventListener('click', () => {
      const r = Math.max(8, Math.min(120, +document.getElementById('rows').value || rows));
      const c = Math.max(8, Math.min(120, +document.getElementById('cols').value || cols));
      rows=r; cols=c; rebuildGrid();
    });

    // Seed a simple central template (core + gates ring)
    document.getElementById('btnSeed').addEventListener('click', () => {
      const cr = Math.floor(rows/2), cc = Math.floor(cols/2);
      for(let r=-2;r<2;r++) for(let c=-2;c<2;c++) setCell(cr+r, cc+c, 'core');
      for(let r=-4;r<=3;r++) { setCell(cr-4, cc+r, 'gates'); setCell(cr+3, cc+r, 'gates'); }
      for(let c=-4;c<=3;c++) { setCell(cr+c, cc-4, 'gates'); setCell(cr+c, cc+3, 'gates'); }
    });

    // Save / Load JSON
    function toJSON(){
      const labels = Array.from(labelMap, ([k,text]) => { const [r,c] = k.split(',').map(Number); return {r,c,text}; });
      return JSON.stringify({ rows, cols, palette: PALETTE, matrix, labels }, null, 2);
    }
    function normalizeMatrix(){
      // ensure all keys exist; unknown -> 'empty'
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(!keyExists(matrix[r][c])) matrix[r][c] = 'empty';
    }
    function fromJSON(obj){
      rows = obj.rows; cols = obj.cols; rebuildGrid();
      if(Array.isArray(obj.palette) && obj.palette.length){ PALETTE = obj.palette; }
      matrix = obj.matrix; normalizeMatrix(); paintAllFromMatrix();
      labelMap.clear();
      if(Array.isArray(obj.labels)) for(const it of obj.labels){ if(Number.isInteger(it.r) && Number.isInteger(it.c) && typeof it.text === 'string'){ setLabel(it.r, it.c, it.text); } }
      buildPalette(); paintAllLabels();
    }

    document.getElementById('btnSaveJSON').addEventListener('click', () => {
      const blob = new Blob([toJSON()], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'map.json'; a.click(); URL.revokeObjectURL(a.href);
    });

    document.getElementById('btnLoadJSON').addEventListener('click', ()=> document.getElementById('fileInput').click());
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0]; if(!file) return;
      const text = await file.text();
      try{ fromJSON(JSON.parse(text)); }
      catch(err){ alert('Invalid JSON file.'); console.error(err); }
      finally{ e.target.value = ''; }
    });

    // Export PNG by drawing matrix + labels to an offscreen <canvas>
    document.getElementById('btnExportPNG').addEventListener('click', () => {
      const scale = 20; const gapPx = 0; const canvas = document.createElement('canvas');
      canvas.width  = cols * scale + (cols-1)*gapPx; canvas.height = rows * scale + (rows-1)*gapPx;
      const ctx = canvas.getContext('2d');
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){ ctx.fillStyle = keyToColor(matrix[r][c]); ctx.fillRect(c*(scale+gapPx), r*(scale+gapPx), scale, scale); }
      ctx.textAlign='center'; ctx.textBaseline='middle'; const fontSize=Math.max(10, Math.floor(scale*0.6)); ctx.font=`700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      for(const [k, text] of labelMap){ if(!text) continue; const [r,c]=k.split(',').map(Number); const x=c*(scale+gapPx)+scale/2, y=r*(scale+gapPx)+scale/2; ctx.lineWidth=Math.max(1, Math.floor(fontSize/4)); ctx.strokeStyle='#000'; ctx.strokeText(text,x,y); ctx.fillStyle='#fff'; ctx.fillText(text,x,y); }
      canvas.toBlob((blob)=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='map.png'; a.click(); URL.revokeObjectURL(a.href); });
    });

    // Export Labels CSV + Clear Labels
    document.getElementById('btnExportLabels').addEventListener('click', () => {
      const rowsCSV = [['label','row','col','type','color']];
      for(const [k, text] of labelMap){ const [r,c] = k.split(',').map(Number); const type = getCellKey(r,c); rowsCSV.push([text,r,c,type,keyToColor(type)]); }
      const csv = rowsCSV.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'labels.csv'; a.click(); URL.revokeObjectURL(a.href);
    });
    document.getElementById('btnClearLabels').addEventListener('click', () => {
      if(!labelMap.size) return;
      if(confirm('Remove all labels? This cannot be undone.')){ labelMap.clear(); paintAllLabels(); }
    });

    // ---- Label Manager UI ----
    function renderLabelList(){
      const entries = Array.from(labelMap, ([k, text]) => { const [r,c]=k.split(',').map(Number); return {r,c,text, key:k}; })
        .sort((a,b) => (a.text||'').localeCompare(b.text||''));
      labelListEl.innerHTML = entries.length ? '' : '<div class="note">No labels yet. Use the Label tool and click on the grid.</div>';
      for(const it of entries){
        const wrap = document.createElement('div'); wrap.className = 'item';
        const tag = document.createElement('span'); tag.className = 'tag'; tag.textContent = it.text; wrap.appendChild(tag);
        const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = `(${it.r}, ${it.c}) • ${getCellKey(it.r,it.c)}`; wrap.appendChild(meta);
        const btns = document.createElement('div'); btns.className = 'btns';
        btns.innerHTML = `
          <button class="btn btn-xs" data-act="jump"   data-k="${it.key}">Jump</button>
          <button class="btn btn-xs" data-act="rename" data-k="${it.key}">Rename</button>
          <button class="btn btn-xs" data-act="del"    data-k="${it.key}">Delete</button>`;
        wrap.appendChild(btns);
        labelListEl.appendChild(wrap);
      }
    }

    labelListEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-act]'); if(!btn) return;
      const [r,c] = btn.dataset.k.split(',').map(Number);
      const act = btn.dataset.act;
      if(act==='jump') jumpToCell(r,c);
      if(act==='rename'){
        const existing = getLabel(r,c) || ''; const text = prompt('New label:', existing); if(text===null) return; if(!text.trim()) return; setLabel(r,c,text.trim());
      }
      if(act==='del') removeLabel(r,c);
    });

    function jumpToCell(r,c){
      const idx = r*cols + c; const cell = gridEl.children[idx]; if(!cell) return;
      cell.classList.remove('flash');
      cell.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
      setTimeout(()=>cell.classList.add('flash'), 200);
      setTimeout(()=>cell.classList.remove('flash'), 1100);
    }

    // ---- Self Tests (non‑destructive) ----
    (function runSelfTests(){
      try{
        console.groupCollapsed('Map Grid – self tests');
        // 1) palette keys unique
        const keys = PALETTE.map(p=>p.key);
        console.assert(new Set(keys).size === keys.length, 'Palette keys should be unique');
        // 2) keyToColor returns a color for every key
        for(const p of PALETTE){ console.assert(/^#/.test(keyToColor(p.key)), `keyToColor must return hex for ${p.key}`); }
        // 3) makeMatrix size
        const m = makeMatrix(3,4,'x');
        console.assert(m.length===3 && m[0].length===4 && m[1][2]==='x', 'makeMatrix builds rows/cols with fill');
        // 4) CSV newline & quoting
        const sample = [['A',1,2,'walls','#fff'],['B',3,4,'core','#000']];
        const csvTest = sample.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(',')).join('\n');
        console.assert(csvTest.includes('\n'), 'CSV should contain newline separators');
        // 5) uniqueKey avoids leading digit
        console.assert(/^t|^[a-z]/.test(uniqueKey('123')), 'uniqueKey should not start with a digit');
        // 6) JSON roundtrip (snapshot/restore) + palette mutation
        const snapshot = { rows, cols, matrix: matrix.map(row=>row.slice()), labels: Array.from(labelMap), palette: JSON.parse(JSON.stringify(PALETTE)) };
        rows=4; cols=4; rebuildGrid(); setCell(1,1,'walls'); setLabel(1,1,'X');
        // add a temporary palette item and paint it
        const tmpKey = uniqueKey('temp'); PALETTE.push({key:tmpKey, name:'Temp', color:'#123456'}); setCell(2,2,tmpKey);
        const saved = toJSON(); const parsed = JSON.parse(saved); fromJSON(parsed);
        console.assert(getLabel(1,1)==='X' && getCellKey(1,1)==='walls', 'Roundtrip should preserve cell + label');
        console.assert(keyExists(tmpKey), 'Roundtrip should preserve custom palette');
        // restore
        rows = snapshot.rows; cols = snapshot.cols; rebuildGrid(); matrix = snapshot.matrix.map(row=>row.slice()); paintAllFromMatrix();
        labelMap.clear(); for(const [k,text] of snapshot.labels){ const [r,c]=k.split(',').map(Number); setLabel(r,c,text); }
        PALETTE = snapshot.palette; buildPalette(); paintAllLabels();
        console.groupEnd();
      }catch(err){ console.error('Self tests failed', err); }
    })();

    // Initialize
    buildPalette();
    rebuildGrid();
  </script>
</body>
</html>
