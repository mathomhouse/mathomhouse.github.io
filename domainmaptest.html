<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Map Grid + Labels</title>
  <style>
    :root{
      --cell: 18px; /* change for bigger/smaller cells */
      --gap: 1px;
      --bg: #0b0b0c;
      --panel: #121218;
      --panel-2: #1a1a22;
      --text: #e9e9ef;
      --muted: #9aa0a6;
      --accent: #6ea8ff;
      --ok: #27c281;
      --warn: #f7b500;
      --bad: #ff4d4f;
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background: linear-gradient(180deg, #0b0b0c, #0f1016);
      color: var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-columns: 360px 1fr; /* a bit wider for new modules */
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header"
        "sidebar main";
    }

    header{
      grid-area: header;
      padding: 12px 16px;
      background: #0e0f14;
      border-bottom: 1px solid #23232b;
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    header h1{ font-size: 16px; margin: 0; letter-spacing: .3px; }
    header .spacer{ flex: 1; }
    header .btn{
      background: var(--panel-2);
      border: 1px solid #2a2a34;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
    }
    header .btn:hover{ filter: brightness(1.1); }

    /* Sidebar */
    aside{
      grid-area: sidebar;
      background: var(--panel);
      border-right: 1px solid #23232b;
      padding: 14px;
      overflow: auto;
    }
    aside h2{ font-size: 13px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); margin: 8px 0 10px; }

    .palette{ display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }
    .swatch-btn{
      display:flex; align-items:center; gap:8px; width:100%;
      padding:8px; background: var(--panel-2); border:1px solid #2a2a34; border-radius: 10px; color:var(--text); cursor:pointer;
    }
    .swatch-btn[aria-pressed="true"]{ outline: 2px solid var(--accent); }
    .swatch{ width:20px; height:20px; border-radius:4px; border:1px solid #0008; box-shadow: inset 0 0 0 1px #ffffff22; }

    label.inline{ display:flex; align-items:center; gap:8px; margin: 8px 0; }
    input[type="number"], input[type="text"], select{ background:#0e0f14; color:var(--text); border:1px solid #2a2a34; border-radius:8px; padding:6px 8px; width: 100%; }

    .toolbar{ display:grid; grid-template-columns: repeat(3,1fr); gap:8px; }
    .btn{ background: var(--panel-2); border: 1px solid #2a2a34; color: var(--text); padding: 8px 10px; border-radius: 10px; cursor: pointer; }
    .btn-xs{ padding:4px 6px; border-radius:8px; font-size:12px; }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }
    .btn[aria-pressed="true"]{ outline:2px solid var(--accent); }

    .note{ color: var(--muted); font-size: 12px; }

    /* Label Manager */
    .list{ display:grid; gap:8px; }
    .item{ display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:8px; background:var(--panel-2); border:1px solid #2a2a34; border-radius:12px; padding:8px; }
    .item .tag{ font-weight:700; padding:2px 8px; border-radius:6px; background:#2a2a34; }
    .item .meta{ color:var(--muted); font-size:12px; }
    .item .btns{ display:flex; gap:6px; }

    /* Metrics */
    .stats{ display:grid; gap:10px; }
    .kv{ display:flex; justify-content:space-between; gap:10px; padding:8px; background:var(--panel-2); border:1px solid #2a2a34; border-radius:10px; }
    .kv .k{ color:var(--muted); }
    .kv .v{ font-weight:700; }
    .rule{ display:flex; justify-content:space-between; align-items:center; gap:10px; padding:8px; border-radius:10px; border:1px solid #2a2a34; background:var(--panel-2); }
    .rule.ok{ outline:1px solid var(--ok); }
    .rule.warn{ outline:1px solid var(--warn); }
    .rule.bad{ outline:1px solid var(--bad); }

    /* Main canvas */
    main{ grid-area: main; display:grid; place-items:center; overflow:auto; }

    .grid-wrap{ position: relative; padding: 18px; }
    .grid{
      --cols: 50;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--cell));
      grid-auto-rows: var(--cell);
      gap: var(--gap);
      background: #1c1c24;
      border: 1px solid #2a2a34;
      padding: var(--gap);
      border-radius: 14px;
      box-shadow: 0 10px 30px #0006, inset 0 0 0 1px #ffffff10;
      image-rendering: pixelated;
      user-select: none;
      touch-action: none; /* smoother touch drag */
    }
    .cell{
      position: relative;
      width: var(--cell);
      height: var(--cell);
      background: #f2f4f7; /* Remaining Area */
      border-radius: 3px;
      box-shadow: inset 0 0 0 1px #00000011;
    }

    /* cell-centered label */
    .cell .lbl{
      pointer-events: none;
      position: absolute; inset: 0; display:flex; align-items:center; justify-content:center;
      font-weight: 700; line-height: 1; letter-spacing: .02em;
      font-size: 11px; /* auto-scaled on export */
      color: #ffffff; /* white text */
      text-shadow:
        -1px 0 #000, 1px 0 #000, 0 -1px #000, 0 1px #000,
        -1px -1px #000, 1px 1px #000, -1px 1px #000, 1px -1px #000; /* outline for contrast */
    }

    /* Flash highlight for jump */
    @keyframes flashRing{ 0%{outline-color:transparent;} 30%{outline-color:var(--accent);} 100%{outline-color:transparent;} }
    .cell.flash{ outline: 2px solid var(--accent); outline-offset: -2px; animation: flashRing .9s ease; }

    .hint{ position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); color:#c6c7cf; font-size:12px; background:#0e0f14aa; padding:6px 10px; border:1px solid #2a2a34; border-radius:999px; }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Map Grid</h1>
    <div class="spacer"></div>
    <button id="btnExportPNG" class="btn" title="Download a PNG of the current map">Export PNG</button>
    <button id="btnSaveJSON" class="btn" title="Download a JSON file you can load later">Save JSON</button>
    <button id="btnLoadJSON" class="btn" title="Load a previously saved JSON file">Load JSON</button>
    <input id="fileInput" type="file" accept="application/json" hidden />
  </header>

  <aside>
    <h2>Palette</h2>
    <div id="palette" class="palette"></div>

    <h2>Tools & Grid</h2>
    <div class="toolbar" style="margin-bottom:10px;">
      <button id="toolBrush" class="btn" aria-pressed="true">Brush</button>
      <button id="toolEraser" class="btn">Eraser</button>
      <button id="toolLabel" class="btn">Label</button>
    </div>

    <label class="inline">Brush size
      <input id="brushSize" type="number" min="1" max="5" value="1"/>
    </label>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
      <label class="inline">Cols
        <input id="cols" type="number" min="8" max="120" value="50" />
      </label>
      <label class="inline">Rows
        <input id="rows" type="number" min="8" max="120" value="50" />
      </label>
    </div>
    <div class="toolbar" style="margin-top:8px; grid-template-columns: repeat(2,1fr);">
      <button id="btnResize" class="btn">Resize Grid</button>
      <button id="btnSeed" class="btn" title="Draw a small core with gates in the center">Seed Template</button>
    </div>

    <h2>POIs & Labels</h2>
    <div class="list" id="labelList"></div>
    <div style="display:flex; gap:8px; margin:8px 0 16px;">
      <button id="btnExportLabels" class="btn" title="Export labels as CSV">Export Labels CSV</button>
      <button id="btnClearLabels" class="btn" title="Remove all labels">Clear</button>
    </div>

    <h2>Map Metrics & Rules</h2>
    <div id="metrics" class="stats"></div>

    <p class="note" style="margin-top:12px;">Tips: Paint = drag • Erase = right‑click • Line = hold <kbd>Shift</kbd> • <strong>Labels:</strong> choose <em>Label</em>, click a cell to enter text (blank to remove). Right‑click while on Label tool removes a label.</p>
  </aside>

  <main>
    <div class="grid-wrap">
      <div id="grid" class="grid" role="grid" aria-label="Editable map grid"></div>
    </div>
  </main>

  <div class="hint">JSON includes labels • PNG export renders labels • Label Manager + Metrics are live</div>

  <script>
    // ---- Configuration ----
    const PALETTE = [
      { key: 'entrance', name: 'Entrances (2–4)',  color: '#0066cc' }, // blue
      { key: 'walls',    name: 'Walls',            color: '#ffd400' }, // yellow
      { key: 'forts',    name: 'Fortresses (6–8)', color: '#db0b19' }, // red
      { key: 'deploy',   name: 'Deployment Area',  color: '#ff59cf' }, // magenta
      { key: 'gates',    name: 'Gates (2–4)',      color: '#2f3132' }, // dark gray
      { key: 'core',     name: 'Core',             color: '#03a34a' }, // green
      { key: 'empty',    name: 'Remaining Area',   color: '#f2f4f7' }, // white
    ];

    const RULES = [
      { key:'entrance', label:'Entrances', min:2, max:4 },
      { key:'gates',    label:'Gates',     min:2, max:4 },
      { key:'forts',    label:'Fortresses',min:6, max:8 },
    ];

    // ---- State ----
    let rows = 50, cols = 50;
    let brush = 'core';
    let tool = 'brush'; // 'brush' | 'eraser' | 'label'
    let brushSize = 1;
    let isMouseDown = false;
    let lastCell = null; // for shift-line drawing

    const gridEl   = document.getElementById('grid');
    const paletteEl= document.getElementById('palette');
    const metricsEl= document.getElementById('metrics');
    const labelListEl = document.getElementById('labelList');

    // Label storage (cell -> text)
    const labelMap = new Map(); // key: "r,c" -> text
    const keyFor = (r,c) => `${r},${c}`;
    function setLabel(r,c,text){ labelMap.set(keyFor(r,c), text); updateCellLabelDOM(r,c); renderLabelList(); }
    function removeLabel(r,c){ labelMap.delete(keyFor(r,c)); updateCellLabelDOM(r,c); renderLabelList(); }
    function getLabel(r,c){ return labelMap.get(keyFor(r,c)); }

    function updateCellLabelDOM(r,c){
      const idx = r*cols + c; const cell = gridEl.children[idx]; if(!cell) return;
      let span = cell.querySelector('.lbl');
      const text = getLabel(r,c);
      if(text && text.trim()){
        if(!span){ span = document.createElement('span'); span.className = 'lbl'; cell.appendChild(span); }
        span.textContent = text;
      } else if(span) { span.remove(); }
    }
    function paintAllLabels(){
      // clear all
      for(const cell of gridEl.children){ const s = cell.querySelector('.lbl'); if(s) s.remove(); }
      for(const [k, text] of labelMap){
        const [r,c] = k.split(',').map(Number); updateCellLabelDOM(r,c);
      }
      renderLabelList();
    }

    // Build palette UI
    function buildPalette(){
      paletteEl.innerHTML = '';
      PALETTE.forEach((p) => {
        const btn = document.createElement('button');
        btn.className = 'swatch-btn';
        btn.setAttribute('type','button');
        btn.setAttribute('aria-pressed', p.key === brush);
        btn.dataset.key = p.key;
        btn.innerHTML = `<span class="swatch" style="background:${p.color}"></span><span>${p.name}</span>`;
        btn.addEventListener('click', () => {
          brush = p.key;
          document.querySelectorAll('.swatch-btn').forEach(b=>b.setAttribute('aria-pressed','false'));
          btn.setAttribute('aria-pressed','true');
        });
        paletteEl.appendChild(btn);
      });
    }

    // Create grid matrix
    let matrix = [];
    function makeMatrix(r, c, fill='empty'){
      return Array.from({length:r}, () => Array.from({length:c}, () => fill));
    }

    function rebuildGrid(){
      gridEl.style.setProperty('--cols', cols);
      gridEl.innerHTML = '';
      matrix = makeMatrix(rows, cols, 'empty');
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.tabIndex = 0;
          cell.dataset.r = r;
          cell.dataset.c = c;
          gridEl.appendChild(cell);
        }
      }
      paintAllFromMatrix();
      paintAllLabels();
      renderMetrics();
    }

    function keyToColor(key){ return (PALETTE.find(p=>p.key===key)||PALETTE.at(-1)).color; }

    function setCell(r,c,key){
      if(r<0||c<0||r>=rows||c>=cols) return;
      matrix[r][c] = key;
      const idx = r*cols + c;
      const cell = gridEl.children[idx];
      if(cell) cell.style.background = keyToColor(key);
      queueMetrics();
    }
    function getCellKey(r,c){ return (matrix[r] && matrix[r][c]) || 'empty'; }

    function paintAllFromMatrix(){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const idx = r*cols + c;
          gridEl.children[idx].style.background = keyToColor(matrix[r][c]);
        }
      }
    }

    // Painting logic
    function paintAt(r,c){
      const radius = Math.max(1, Math.floor(brushSize));
      const half = Math.floor(radius/2);
      for(let dr=0; dr<radius; dr++){
        for(let dc=0; dc<radius; dc++){
          const rr = r + dr - half;
          const cc = c + dc - half;
          if(tool === 'eraser') setCell(rr,cc,'empty');
          else setCell(rr,cc,brush);
        }
      }
    }

    function linePaint(r0,c0,r1,c1){
      // Bresenham-ish
      let dx = Math.abs(c1 - c0), sx = c0 < c1 ? 1 : -1;
      let dy = -Math.abs(r1 - r0), sy = r0 < r1 ? 1 : -1; 
      let err = dx + dy, e2;
      while(true){
        paintAt(r0,c0);
        if (c0 === c1 && r0 === r1) break;
        e2 = 2*err;
        if (e2 >= dy) { err += dy; c0 += sx; }
        if (e2 <= dx) { err += dx; r0 += sy; }
      }
    }

    gridEl.addEventListener('contextmenu', e => e.preventDefault());

    gridEl.addEventListener('pointerdown', (e) => {
      const target = e.target;
      if(!target.classList.contains('cell')) return;
      e.preventDefault();
      isMouseDown = true;
      const r = +target.dataset.r; const c = +target.dataset.c;

      if(tool === 'label'){
        if(e.button === 2){ removeLabel(r,c); }
        else {
          const existing = getLabel(r,c) || '';
          const text = prompt('Label for this cell (blank to remove):', existing);
          if(text === null) { /* cancel */ }
          else if(!text.trim()) removeLabel(r,c);
          else setLabel(r,c, text.trim());
        }
        lastCell = target; return;
      }

      // painting tools
      const useEraser = (e.button === 2 || e.ctrlKey);
      const prevTool = tool; if(useEraser) tool = 'eraser';
      if(e.shiftKey && lastCell){
        linePaint(+lastCell.dataset.r, +lastCell.dataset.c, r, c);
      } else {
        paintAt(r,c);
      }
      if(useEraser) tool = prevTool;
      lastCell = target;
    });

    gridEl.addEventListener('pointermove', (e) => {
      if(!isMouseDown) return;
      const target = e.target;
      if(!target.classList.contains('cell')) return;
      const r = +target.dataset.r; const c = +target.dataset.c;
      if(tool === 'label') return; // no drag labels
      paintAt(r,c);
      lastCell = target;
    });
    window.addEventListener('pointerup', () => { isMouseDown = false; });

    // Controls
    function setTool(name){
      tool = name;
      document.getElementById('toolBrush').setAttribute('aria-pressed', String(name==='brush'));
      document.getElementById('toolEraser').setAttribute('aria-pressed', String(name==='eraser'));
      document.getElementById('toolLabel').setAttribute('aria-pressed', String(name==='label'));
    }

    document.getElementById('toolBrush').addEventListener('click', () => setTool('brush'));
    document.getElementById('toolEraser').addEventListener('click', () => setTool('eraser'));
    document.getElementById('toolLabel').addEventListener('click', () => setTool('label'));

    document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value || 1);

    document.getElementById('btnResize').addEventListener('click', () => {
      const r = Math.max(8, Math.min(120, +document.getElementById('rows').value || rows));
      const c = Math.max(8, Math.min(120, +document.getElementById('cols').value || cols));
      rows=r; cols=c; rebuildGrid();
    });

    // Seed a simple central template (core + gates ring)
    document.getElementById('btnSeed').addEventListener('click', () => {
      const cr = Math.floor(rows/2), cc = Math.floor(cols/2);
      // core 4x4
      for(let r=-2;r<2;r++) for(let c=-2;c<2;c++) setCell(cr+r, cc+c, 'core');
      // gates (dark gray) single ring around a 6x6 area
      for(let r=-4;r<=3;r++) { setCell(cr-4, cc+r, 'gates'); setCell(cr+3, cc+r, 'gates'); }
      for(let c=-4;c<=3;c++) { setCell(cr+c, cc-4, 'gates'); setCell(cr+c, cc+3, 'gates'); }
    });

    // Save / Load JSON
    function toJSON(){
      const labels = Array.from(labelMap, ([k,text]) => { const [r,c] = k.split(',').map(Number); return {r,c,text}; });
      return JSON.stringify({ rows, cols, palette: PALETTE, matrix, labels }, null, 2);
    }
    function fromJSON(obj){
      rows = obj.rows; cols = obj.cols; rebuildGrid();
      matrix = obj.matrix; paintAllFromMatrix();
      labelMap.clear();
      if(Array.isArray(obj.labels)){
        for(const it of obj.labels){ if(Number.isInteger(it.r) && Number.isInteger(it.c) && typeof it.text === 'string'){ setLabel(it.r, it.c, it.text); } }
      }
      paintAllLabels();
      renderMetrics();
    }

    document.getElementById('btnSaveJSON').addEventListener('click', () => {
      const blob = new Blob([toJSON()], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'map.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // IMPORTANT: Don't redeclare a variable named `fileInput`. Just use the element by id.
    document.getElementById('btnLoadJSON').addEventListener('click', ()=> document.getElementById('fileInput').click());
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0]; if(!file) return;
      const text = await file.text();
      try{ fromJSON(JSON.parse(text)); }
      catch(err){ alert('Invalid JSON file.'); console.error(err); }
      finally{ e.target.value = ''; }
    });

    // Export PNG by drawing matrix + labels to an offscreen <canvas>
    document.getElementById('btnExportPNG').addEventListener('click', () => {
      const scale = 20; // pixels per cell
      const gapPx = 0;  // no gaps in exported image
      const canvas = document.createElement('canvas');
      canvas.width  = cols * scale + (cols-1)*gapPx;
      canvas.height = rows * scale + (rows-1)*gapPx;
      const ctx = canvas.getContext('2d');

      // cells
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          ctx.fillStyle = keyToColor(matrix[r][c]);
          ctx.fillRect(c*(scale+gapPx), r*(scale+gapPx), scale, scale);
        }
      }

      // labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const fontSize = Math.max(10, Math.floor(scale * 0.6));
      ctx.font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

      for(const [k, text] of labelMap){
        if(!text) continue;
        const [r,c] = k.split(',').map(Number);
        const x = c*(scale+gapPx) + scale/2;
        const y = r*(scale+gapPx) + scale/2;
        // outline then fill for contrast
        ctx.lineWidth = Math.max(1, Math.floor(fontSize/4));
        ctx.strokeStyle = '#000';
        ctx.strokeText(text, x, y);
        ctx.fillStyle = '#fff';
        ctx.fillText(text, x, y);
      }

      canvas.toBlob((blob)=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'map.png';
        a.click();
        URL.revokeObjectURL(a.href);
      });
    });

    // ---- Label Manager UI ----
    function renderLabelList(){
      const entries = Array.from(labelMap, ([k, text]) => { const [r,c]=k.split(',').map(Number); return {r,c,text, key:k}; })
        .sort((a,b) => (a.text||'').localeCompare(b.text||''));
      labelListEl.innerHTML = entries.length ? '' : '<div class="note">No labels yet. Use the Label tool and click on the grid.</div>';
      for(const it of entries){
        const wrap = document.createElement('div'); wrap.className = 'item';
        const tag = document.createElement('span'); tag.className = 'tag'; tag.textContent = it.text; wrap.appendChild(tag);
        const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = `(${it.r}, ${it.c}) • ${getCellKey(it.r,it.c)}`; wrap.appendChild(meta);
        const btns = document.createElement('div'); btns.className = 'btns';
        btns.innerHTML = `
          <button class="btn btn-xs" data-act="jump"   data-k="${it.key}">Jump</button>
          <button class="btn btn-xs" data-act="rename" data-k="${it.key}">Rename</button>
          <button class="btn btn-xs" data-act="del"    data-k="${it.key}">Delete</button>`;
        wrap.appendChild(btns);
        labelListEl.appendChild(wrap);
      }
    }

    labelListEl.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-act]'); if(!btn) return;
      const [r,c] = btn.dataset.k.split(',').map(Number);
      const act = btn.dataset.act;
      if(act==='jump') jumpToCell(r,c);
      if(act==='rename'){
        const existing = getLabel(r,c) || ''; const text = prompt('New label:', existing); if(text===null) return; if(!text.trim()) return; setLabel(r,c,text.trim());
      }
      if(act==='del') removeLabel(r,c);
    });

    function jumpToCell(r,c){
      const idx = r*cols + c; const cell = gridEl.children[idx]; if(!cell) return;
      cell.classList.remove('flash');
      cell.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
      setTimeout(()=>cell.classList.add('flash'), 200);
      setTimeout(()=>cell.classList.remove('flash'), 1100);
    }

    // Export labels CSV
    document.getElementById('btnExportLabels').addEventListener('click', () => {
      const rowsCSV = [['label','row','col','type','color']];
      for(const [k, text] of labelMap){ const [r,c] = k.split(',').map(Number); const type = getCellKey(r,c); rowsCSV.push([text,r,c,type,keyToColor(type)]); }
      const csv = rowsCSV.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'labels.csv'; a.click(); URL.revokeObjectURL(a.href);
    });
    document.getElementById('btnClearLabels').addEventListener('click', () => {
      if(!labelMap.size) return;
      if(confirm('Remove all labels? This cannot be undone.')){ labelMap.clear(); paintAllLabels(); }
    });

    // ---- Metrics & Rules ----
    let needsMetrics = false;
    function queueMetrics(){ if(needsMetrics) return; needsMetrics = true; requestAnimationFrame(()=>{ needsMetrics=false; renderMetrics(); }); }

    function computeCounts(){
      const cellCounts = Object.fromEntries(PALETTE.map(p=>[p.key,0]));
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) cellCounts[matrix[r][c]]++;
      const clusterCounts = {};
      for(const r of RULES){ clusterCounts[r.key] = countClusters(r.key); }
      return {cellCounts, clusterCounts};
    }

    function renderMetrics(){
      const {cellCounts, clusterCounts} = computeCounts();
      metricsEl.innerHTML = '';
      // Totals by palette
      for(const p of PALETTE){
        const row = document.createElement('div'); row.className = 'kv';
        row.innerHTML = `<span class="k">${p.name}</span><span class="v">${cellCounts[p.key]}</span>`;
        metricsEl.appendChild(row);
      }
      // Rules
      for(const rule of RULES){
        const n = clusterCounts[rule.key] ?? 0;
        let cls = 'ok', msg = 'OK';
        if(n < rule.min){ cls='bad'; msg = `Too few (have ${n}, need \u2265${rule.min})`; }
        else if(n > rule.max){ cls='bad'; msg = `Too many (have ${n}, need \u2264${rule.max})`; }
        else if(n === rule.min || n === rule.max){ cls='warn'; msg = `Edge of range (${n} in ${rule.min}–${rule.max})`; }
        const row = document.createElement('div'); row.className = `rule ${cls}`;
        row.innerHTML = `<span>${rule.label} clusters</span><strong>${n}</strong><span class="note">${msg}</span>`;
        metricsEl.appendChild(row);
      }
    }

    function countClusters(key){
      // 4-neighbor connectivity for regions of a given key
      const seen = new Set(); let count = 0;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const enc = (r,c)=>r+','+c;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(matrix[r][c]!==key) continue; const k=enc(r,c); if(seen.has(k)) continue;
          count++; const q=[[r,c]]; seen.add(k);
          while(q.length){
            const [rr,cc] = q.pop();
            for(const [dr,dc] of dirs){
              const nr=rr+dr, nc=cc+dc; if(nr<0||nc<0||nr>=rows||nc>=cols) continue;
              if(matrix[nr][nc]!==key) continue; const kk=enc(nr,nc); if(seen.has(kk)) continue;
              seen.add(kk); q.push([nr,nc]);
            }
          }
        }
      }
      return count;
    }

    // ---- Self Tests (non‑destructive) ----
    (function runSelfTests(){
      try{
        console.groupCollapsed('Map Grid – self tests');
        // 1) palette keys unique
        const keys = PALETTE.map(p=>p.key);
        console.assert(new Set(keys).size === keys.length, 'Palette keys should be unique');
        // 2) keyToColor returns a color for every key
        for(const p of PALETTE){ console.assert(/^#/.test(keyToColor(p.key)), `keyToColor must return hex for ${p.key}`); }
        // 3) makeMatrix size
        const m = makeMatrix(3,4,'x');
        console.assert(m.length===3 && m[0].length===4 && m[1][2]==='x', 'makeMatrix builds rows/cols with fill');
        // 4) cluster counter on a toy matrix (local, no globals)
        const toy = [ ['a','a','b'], ['a','b','b'], ['c','c','b'] ];
        const cc = (mat,key)=>{ // local helper, correctly scoped
          const R = mat.length, C = mat[0].length;
          const seen = new Set(); let n = 0;
          const enc=(r,c)=>r+','+c; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          for(let r=0;r<R;r++){
            for(let c=0;c<C;c++){
              if(mat[r][c]!==key) continue; const k=enc(r,c); if(seen.has(k)) continue;
              n++; const q=[[r,c]]; seen.add(k);
              while(q.length){
                const [rr,cc2]=q.pop();
                for(const [dr,dc] of dirs){
                  const nr=rr+dr, nc=cc2+dc; if(nr<0||nc<0||nr>=R||nc>=C) continue;
                  if(mat[nr][nc]!==key) continue; const kk=enc(nr,nc); if(!seen.has(kk)){ seen.add(kk); q.push([nr,nc]); }
                }
              }
            }
          }
          return n;
        };
        console.assert(cc(toy,'a')===1 && cc(toy,'b')===1 && cc(toy,'c')===1, 'cluster counter groups 4-neighbors');
        // 5) CSV newline & quoting
        const sample = [['A',1,2,'walls','#fff'],['B',3,4,'core','#000']];
        const csvTest = sample.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(',')).join('\n');
        console.assert(csvTest.includes('\n'), 'CSV should contain newline separators');
        // 6) JSON roundtrip (snapshot & restore to avoid side-effects)
        const snapshot = { rows, cols, matrix: matrix.map(row=>row.slice()), labels: Array.from(labelMap) };
        rows=4; cols=4; rebuildGrid(); setCell(1,1,'walls'); setLabel(1,1,'X');
        const saved = toJSON(); const parsed = JSON.parse(saved); fromJSON(parsed);
        console.assert(getLabel(1,1)==='X' && getCellKey(1,1)==='walls', 'Roundtrip should preserve cell + label');
        // restore
        rows = snapshot.rows; cols = snapshot.cols; rebuildGrid();
        matrix = snapshot.matrix.map(row=>row.slice()); paintAllFromMatrix();
        labelMap.clear(); for(const [k,text] of snapshot.labels){ const [r,c]=k.split(',').map(Number); setLabel(r,c,text); }
        paintAllLabels(); renderMetrics();
        console.groupEnd();
      }catch(err){ console.error('Self tests failed', err); }
    })();

    // Initialize
    buildPalette();
    rebuildGrid();
  </script>
</body>
</html>
